"""Middleware for rate limiting and request validation."""
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from fastapi import Request, HTTPException
import re

# Rate limiter with SlowAPI
limiter = Limiter(
    key_func=get_remote_address,
    default_limits=["100/minute"],
    storage_uri="memory://",
    strategy="fixed-window"
)

# Input validation patterns
SAFE_STRING_PATTERN = re.compile(r'^[a-zA-Z0-9._-]+
)
IP_CIDR_PATTERN = re.compile(r'^(\d{1,3}\.){3}\d{1,3}/\d{1,2}
)
NEBULA_IP_PATTERN = re.compile(r'^(\d{1,3}\.){3}\d{1,3}/\d{1,2}
)
EMAIL_PATTERN = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
)
USERNAME_PATTERN = re.compile(r'^[a-zA-Z0-9_-]{3,50}
)

def validate_certificate_name(name: str) -> bool:
    """Validate certificate name format."""
    if not name or len(name) > 100:
        return False
    return bool(SAFE_STRING_PATTERN.match(name))

def validate_ip_cidr(ip: str) -> bool:
    """Validate IP/CIDR format."""
    if not IP_CIDR_PATTERN.match(ip):
        return False
    
    # Validate IP ranges
    parts = ip.split('/')
    ip_parts = parts[0].split('.')
    
    for part in ip_parts:
        if not 0 <= int(part) <= 255:
            return False
    
    # Validate CIDR
    cidr = int(parts[1])
    if not 0 <= cidr <= 32:
        return False
    
    return True

def validate_config_name(name: str) -> bool:
    """Validate configuration name."""
    if not name or len(name) > 100:
        return False
    return bool(SAFE_STRING_PATTERN.match(name))

def validate_username(username: str) -> bool:
    """Validate username format."""
    if not username or len(username) < 3 or len(username) > 50:
        return False
    return bool(USERNAME_PATTERN.match(username))

def validate_email(email: str) -> bool:
    """Validate email format."""
    if not email or len(email) > 255:
        return False
    return bool(EMAIL_PATTERN.match(email))

def sanitize_input(input_str: str, max_length: int = 1000) -> str:
    """Sanitize user input to prevent injection attacks."""
    if not input_str:
        return ""
    
    # Truncate to max length
    sanitized = input_str[:max_length]
    
    # Remove potential SQL injection characters
    dangerous_chars = ["'", '"', ';', '--', '/*', '*/', 'xp_', 'sp_']
    for char in dangerous_chars:
        sanitized = sanitized.replace(char, '')
    
    return sanitized.strip()

async def validate_request_size(request: Request):
    """Limit request body size to prevent DoS."""
    body = await request.body()
    max_size = 10 * 1024 * 1024  # 10MB
    if len(body) > max_size:
        raise HTTPException(
            status_code=413,
            detail="Request body too large"
        )

def validate_groups(groups: str) -> bool:
    """Validate Nebula groups format (comma-separated)."""
    if not groups:
        return True  # Empty groups is valid
    
    if len(groups) > 500:
        return False
    
    # Split by comma and validate each group
    group_list = [g.strip() for g in groups.split(',')]
    
    for group in group_list:
        if not group:  # Empty group after split
            return False
        if len(group) > 50:
            return False
        if not re.match(r'^[a-zA-Z0-9_-]+
, group):
            return False
    
    return True

def validate_duration(duration: int) -> bool:
    """Validate certificate duration in hours."""
    # Min 1 hour, max 10 years (87600 hours)
    return 1 <= duration <= 87600

def validate_port(port: int) -> bool:
    """Validate port number."""
    return 1 <= port <= 65535

def validate_yaml_safe(content: str) -> bool:
    """Basic YAML safety check."""
    if not content:
        return False
    
    # Check for dangerous YAML features
    dangerous_patterns = [
        '!!python',  # Python object instantiation
        '!!exec',    # Execution
        '!!map',     # Might be used maliciously
    ]
    
    content_lower = content.lower()
    for pattern in dangerous_patterns:
        if pattern in content_lower:
            return False
    
    return True